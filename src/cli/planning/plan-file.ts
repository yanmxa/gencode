/**
 * Plan File Utilities
 *
 * Manages plan files stored in .gen/plans/ directory.
 * Generates unique filenames with timestamps and slugs.
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { existsSync } from 'fs';
import type { PlanFile } from './types.js';

// ============================================================================
// Constants
// ============================================================================

const PLANS_DIR = '.gen/plans';
const PLAN_FILE_EXTENSION = '.md';

// Word lists for generating memorable names (like Claude Code)
const ADJECTIVES = [
  'agile', 'bold', 'calm', 'deft', 'eager', 'fair', 'glad', 'humble',
  'ideal', 'jolly', 'keen', 'lively', 'merry', 'noble', 'polite', 'quiet',
  'rapid', 'smart', 'tidy', 'unique', 'vivid', 'warm', 'zealous', 'bright',
  'clear', 'crisp', 'fresh', 'golden', 'happy', 'lovely', 'neat', 'proud',
];

const NOUNS = [
  'alpine', 'beacon', 'cipher', 'delta', 'ember', 'falcon', 'glacier', 'harbor',
  'island', 'jasper', 'kayak', 'lantern', 'marble', 'nebula', 'oracle', 'prism',
  'quartz', 'rapids', 'summit', 'timber', 'unity', 'vertex', 'willow', 'zenith',
  'arrow', 'bridge', 'canyon', 'dawn', 'echo', 'forest', 'grove', 'hollow',
];

// ============================================================================
// Name Generation
// ============================================================================

/**
 * Generate a memorable plan name (adjective-noun)
 * Example: "agile-beacon", "bold-cipher"
 */
function generateMemorableName(): string {
  const adjective = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
  const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
  return `${adjective}-${noun}`;
}

/**
 * Generate a slug from text (for task-specific naming)
 */
function generateSlug(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '') // Remove special chars
    .replace(/\s+/g, '-') // Replace spaces with dashes
    .replace(/-+/g, '-') // Collapse multiple dashes
    .slice(0, 30) // Limit length
    .replace(/^-|-$/g, ''); // Trim dashes from ends
}

/**
 * Generate plan file name
 * Format: <memorable-name>.md (like Claude Code)
 */
export function generatePlanFileName(taskDescription?: string): string {
  // Use memorable name like Claude Code (melodic-humming-lampson)
  const name = generateMemorableName();
  return `${name}${PLAN_FILE_EXTENSION}`;
}

// ============================================================================
// Directory Management
// ============================================================================

/**
 * Get the plans directory path for a project
 */
export function getPlansDir(cwd: string): string {
  return path.join(cwd, PLANS_DIR);
}

/**
 * Ensure the plans directory exists
 */
export async function ensurePlansDir(cwd: string): Promise<string> {
  const plansDir = getPlansDir(cwd);

  if (!existsSync(plansDir)) {
    await fs.mkdir(plansDir, { recursive: true });
  }

  return plansDir;
}

// ============================================================================
// Plan File Operations
// ============================================================================

/**
 * Create a new plan file
 */
export async function createPlanFile(
  cwd: string,
  taskDescription?: string
): Promise<PlanFile> {
  const plansDir = await ensurePlansDir(cwd);
  const fileName = generatePlanFileName(taskDescription);
  const filePath = path.join(plansDir, fileName);

  // Initial plan template
  const initialContent = `# Implementation Plan

## Task
${taskDescription || 'Describe the task here...'}

## Analysis
_Understanding the codebase and requirements..._

## Approach
_Design decisions and implementation strategy..._

## Files to Change
- [ ] File 1 (action)
- [ ] File 2 (action)

## Steps
1. Step 1
2. Step 2
3. Step 3

## Pre-approved Permissions
_Commands that will be allowed during execution..._

---
_Generated by GenCode Plan Mode_
`;

  const now = new Date();
  await fs.writeFile(filePath, initialContent, 'utf-8');

  return {
    path: filePath,
    content: initialContent,
    createdAt: now,
    updatedAt: now,
  };
}

/**
 * Read a plan file
 */
export async function readPlanFile(filePath: string): Promise<PlanFile | null> {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const stats = await fs.stat(filePath);

    return {
      path: filePath,
      content,
      createdAt: stats.birthtime,
      updatedAt: stats.mtime,
    };
  } catch {
    return null;
  }
}

/**
 * Write to a plan file
 */
export async function writePlanFile(filePath: string, content: string): Promise<void> {
  // Ensure directory exists
  const dir = path.dirname(filePath);
  if (!existsSync(dir)) {
    await fs.mkdir(dir, { recursive: true });
  }

  await fs.writeFile(filePath, content, 'utf-8');
}

/**
 * List all plan files in the project
 */
export async function listPlanFiles(cwd: string): Promise<PlanFile[]> {
  const plansDir = getPlansDir(cwd);

  if (!existsSync(plansDir)) {
    return [];
  }

  try {
    const files = await fs.readdir(plansDir);
    const planFiles: PlanFile[] = [];

    for (const file of files) {
      if (file.endsWith(PLAN_FILE_EXTENSION)) {
        const filePath = path.join(plansDir, file);
        const planFile = await readPlanFile(filePath);
        if (planFile) {
          planFiles.push(planFile);
        }
      }
    }

    // Sort by updated time, newest first
    planFiles.sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());

    return planFiles;
  } catch {
    return [];
  }
}

/**
 * Delete a plan file
 */
export async function deletePlanFile(filePath: string): Promise<boolean> {
  try {
    await fs.unlink(filePath);
    return true;
  } catch {
    return false;
  }
}

// ============================================================================
// Plan Content Parsing
// ============================================================================

/**
 * Extract files to change from plan content
 */
export function parseFilesToChange(
  content: string
): Array<{ path: string; action: 'create' | 'modify' | 'delete' }> {
  const files: Array<{ path: string; action: 'create' | 'modify' | 'delete' }> = [];

  // Look for patterns like:
  // - [ ] src/file.ts (create)
  // - [x] src/file.ts (modify)
  // + src/file.ts (create)
  // ~ src/file.ts (modify)
  // - src/file.ts (delete)

  const lines = content.split('\n');
  for (const line of lines) {
    // Checkbox format
    let match = line.match(/^[-*]\s*\[[ x]\]\s+([^\s(]+)\s*\((\w+)\)/);
    if (match) {
      const [, filePath, action] = match;
      if (action === 'create' || action === 'modify' || action === 'delete') {
        files.push({ path: filePath, action });
      }
      continue;
    }

    // Symbol format (+, ~, -)
    match = line.match(/^\s*([+~-])\s+([^\s(]+)(?:\s*\((\w+)\))?/);
    if (match) {
      const [, symbol, filePath, explicitAction] = match;
      let action: 'create' | 'modify' | 'delete';

      if (explicitAction === 'create' || explicitAction === 'modify' || explicitAction === 'delete') {
        action = explicitAction;
      } else {
        action = symbol === '+' ? 'create' : symbol === '~' ? 'modify' : 'delete';
      }

      files.push({ path: filePath, action });
    }
  }

  return files;
}

/**
 * Extract pre-approved permissions from plan content
 */
export function parsePreApprovedPermissions(content: string): Array<{ tool: 'Bash'; prompt: string }> {
  const permissions: Array<{ tool: 'Bash'; prompt: string }> = [];

  // Look for patterns like:
  // - Bash: run tests
  // - npm test
  // - npm install

  const permissionSection = content.match(/## Pre-approved Permissions[\s\S]*?(?=##|$)/i);
  if (!permissionSection) {
    return permissions;
  }

  const lines = permissionSection[0].split('\n');
  for (const line of lines) {
    // Skip header and empty lines
    if (line.startsWith('##') || line.startsWith('_') || !line.trim()) {
      continue;
    }

    // Match "- Bash: description" or "- description"
    const match = line.match(/^[-*]\s+(?:Bash:\s+)?(.+)/);
    if (match) {
      permissions.push({ tool: 'Bash', prompt: match[1].trim() });
    }
  }

  return permissions;
}

/**
 * Get relative path for display
 */
export function getDisplayPath(fullPath: string, cwd: string): string {
  const relativePath = path.relative(cwd, fullPath);
  const home = process.env.HOME || '';

  if (relativePath.startsWith('..')) {
    // Path is outside cwd, try home-relative
    if (fullPath.startsWith(home)) {
      return '~' + fullPath.slice(home.length);
    }
    return fullPath;
  }

  return relativePath;
}
